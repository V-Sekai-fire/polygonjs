/**
 * Update a scene before some passes are rendered
 *
 * @remarks
 * The node can also be provided a second input, which has to be an UpdateScene post node.
 * This node will then be able to reset the changes made by this node.
 *
 */
import {TypedPostProcessNode, TypedPostNodeContext, PostParamOptions} from './_Base';
import {UpdateScenePass} from '../../../modules/core/post_process/UpdateScenePass';
import {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';
import {isBooleanTrue} from '../../../core/Type';
import {BaseNodeType} from '../_Base';

class UpdateScenePostParamsConfig extends NodeParamsConfig {
	/** @param reset */
	reset = ParamConfig.BOOLEAN(0, {
		...PostParamOptions,
	});
	/** @param objects Mask */
	objectsMask = ParamConfig.STRING('*', {
		...PostParamOptions,
		visibleIf: {reset: 0},
	});
	/** @param invertMask */
	invertMask = ParamConfig.BOOLEAN(0, {
		...PostParamOptions,
		visibleIf: {reset: 0},
	});
	/** @param prints which objects are targeted by this node, for debugging */
	printFoundObjectsFromMask = ParamConfig.BUTTON(null, {
		visibleIf: {reset: 0},
		callback: (node: BaseNodeType) => {
			UpdateScenePostNode.PARAM_CALLBACK_printResolve(node as UpdateScenePostNode);
		},
	});
	/** @param update selected objects material to a matte one */
	setMatteMaterial = ParamConfig.BOOLEAN(1, {
		...PostParamOptions,
		visibleIf: {reset: 0},
	});
	/** @param set visible state  */
	setVisible = ParamConfig.BOOLEAN(0, {
		...PostParamOptions,
		visibleIf: {reset: 0},
	});
	/** @param set visible state  */
	visible = ParamConfig.BOOLEAN(0, {
		...PostParamOptions,
		visibleIf: {reset: 0, setVisible: 1},
	});
	/** @param reset */
	resetChanges = ParamConfig.BUTTON(null, {
		visibleIf: {reset: 0},
		callback: (node: BaseNodeType) => {
			UpdateScenePostNode.PARAM_CALLBACK_resetMat(node as UpdateScenePostNode);
		},
	});
	/** @param material */
	// material = ParamConfig.NODE_PATH('', {
	// 	...PostParamOptions,
	// 	visibleIf: {overrideMaterial: 1},
	// 	nodeSelection: {
	// 		context: NodeContext.MAT,
	// 	},
	// 	callback: (node: BaseNodeType) => {
	// 		UpdateScenePostNode.PARAM_CALLBACK_updatePassesMaterial(node as UpdateScenePostNode);
	// 	},
	// });
}
const ParamsConfig = new UpdateScenePostParamsConfig();
export class UpdateScenePostNode extends TypedPostProcessNode<UpdateScenePass, UpdateScenePostParamsConfig> {
	override paramsConfig = ParamsConfig;
	static override type() {
		return 'updateScene';
	}
	override initializeNode() {
		super.initializeNode();
		this.io.inputs.setCount(0, 2);
	}
	static override displayedInputNames(): string[] {
		return ['previous pass', 'updateScene node to reset changes of'];
	}

	protected override _createPass(context: TypedPostNodeContext) {
		const pass = new UpdateScenePass({
			scene: this.scene(),
			reset: isBooleanTrue(this.pv.reset),
			passToReset: this._passToReset(context.requester),
			objectsMask: this.pv.objectsMask,
			invertMask: isBooleanTrue(this.pv.invertMask),
			setMatteMaterial: isBooleanTrue(this.pv.setMatteMaterial),
			setVisible: isBooleanTrue(this.pv.setVisible),
			visible: isBooleanTrue(this.pv.visible),
		});
		return pass;
	}
	override updatePass(pass: UpdateScenePass) {
		pass.reset = isBooleanTrue(this.pv.reset);
		pass.objectsMask = this.pv.objectsMask;
		pass.invertMask = isBooleanTrue(this.pv.invertMask);
		pass.setMatteMaterial = isBooleanTrue(this.pv.setMatteMaterial);
		pass.setVisible = isBooleanTrue(this.pv.setVisible);
		pass.visible = isBooleanTrue(this.pv.visible);
	}
	private _passToReset(requester: BaseNodeType): UpdateScenePass | undefined {
		const input2 = this.io.inputs.input(1);
		if (!input2) {
			return;
		}
		if (input2 instanceof UpdateScenePostNode) {
			return input2.passesByRequester(requester);
		}
	}

	static PARAM_CALLBACK_printResolve(node: UpdateScenePostNode) {
		node._printResolve();
	}
	private _printResolve() {
		let firstPass: UpdateScenePass | undefined;
		this._passesByRequesterId.forEach((pass) => {
			firstPass = firstPass || pass;
		});
		if (firstPass) {
			console.log(firstPass.objectsList());
		} else {
			console.error(`no pass generated by this node, maybe it has not rendered yet?`);
		}
	}
	static PARAM_CALLBACK_resetMat(node: UpdateScenePostNode) {
		node._resetMat();
	}
	private _resetMat() {
		this._passesByRequesterId.forEach((pass) => {
			pass.resetChanges();
		});
	}

	// static PARAM_CALLBACK_updatePassesMaterial(node: UpdateScenePostNode) {
	// 	node._updatePassesMaterial();
	// }
	// private _updatePassesMaterial() {
	// 	const matNode = this.pv.material.nodeWithContext(NodeContext.MAT);
	// 	if (!matNode) {
	// 		this._passes_by_requester_id.forEach((pass) => {
	// 			pass.material = undefined;
	// 		});
	// 	} else {
	// 		const mat = matNode.material;
	// 		this._passes_by_requester_id.forEach((pass) => {
	// 			pass.material = mat;
	// 		});
	// 	}
	// }
}
