/**
 * Adds an Unreal Bloom effect.
 *
 *
 */
import {Vector2} from 'three/src/math/Vector2';
import {TypedPostProcessNode, TypedPostNodeContext, PostParamOptions} from './_Base';
// import {UnrealBloomPass} from '../../../modules/three/examples/jsm/postprocessing/UnrealBloomPass';
import {UnrealBloomPass} from '../../../modules/core/post_process/UnrealBloomPass';

import {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';
import {isBooleanTrue} from '../../../core/Type';
// import {isBooleanTrue} from '../../../core/Type';
// import {BaseNodeType} from '../_Base';
class UnrealBloomPostParamsConfig extends NodeParamsConfig {
	/** @param effect strength */
	strength = ParamConfig.FLOAT(1.5, {
		range: [0, 3],
		rangeLocked: [true, false],
		...PostParamOptions,
	});
	/** @param effect radius */
	radius = ParamConfig.FLOAT(1, {
		...PostParamOptions,
	});
	/** @param effect threshold */
	threshold = ParamConfig.FLOAT(0, {
		...PostParamOptions,
	});
	/** @param premult */
	premult = ParamConfig.BOOLEAN(0, {
		...PostParamOptions,
	});
	/** @param override rendered Objects */
	// overrideObjects = ParamConfig.BOOLEAN(0, {
	// 	...PostParamOptions,
	// });
	/** @param objects Mask */
	// objectsMask = ParamConfig.STRING('*', {
	// 	...PostParamOptions,
	// 	visibleIf: {overrideObjects: 1},
	// });
	/** @param prints which objects are targeted by this node, for debugging */
	// printFoundObjectsFromMask = ParamConfig.BUTTON(null, {
	// 	visibleIf: {overrideObjects: 1},
	// 	callback: (node: BaseNodeType) => {
	// 		UnrealBloomPostNode.PARAM_CALLBACK_printResolve(node as UnrealBloomPostNode);
	// 	},
	// });
}
const ParamsConfig = new UnrealBloomPostParamsConfig();
export class UnrealBloomPostNode extends TypedPostProcessNode<UnrealBloomPass, UnrealBloomPostParamsConfig> {
	paramsConfig = ParamsConfig;
	static type() {
		return 'unrealBloom';
	}

	protected _createPass(context: TypedPostNodeContext) {
		const pass = new UnrealBloomPass({
			resolution: new Vector2(context.resolution.x, context.resolution.y),
			strength: this.pv.strength,
			radius: this.pv.radius,
			threshold: this.pv.threshold,
			premult: isBooleanTrue(this.pv.premult),
			// overrideObjects: this.pv.overrideObjects,
			// scene: this.scene(),
			// objectsMask: this.pv.objectsMask,
		});
		return pass;
	}
	updatePass(pass: UnrealBloomPass) {
		pass.strength = this.pv.strength;
		pass.radius = this.pv.radius;
		pass.threshold = this.pv.threshold;
		pass.premult = this.pv.premult;
		// pass.overrideObjects = isBooleanTrue(this.pv.overrideObjects);
		// if (pass.overrideObjects) {
		// 	pass.objectsMask = this.pv.objectsMask;
		// }
	}

	// static PARAM_CALLBACK_printResolve(node: UnrealBloomPostNode) {
	// 	node._printResolve();
	// }
	// private _printResolve() {
	// 	let firstPass: UnrealBloomPass | undefined;
	// 	this._passes_by_requester_id.forEach((pass) => {
	// 		firstPass = firstPass || pass;
	// 	});
	// 	if (firstPass) {
	// 		console.log(firstPass.meshesList());
	// 	} else {
	// 		console.error(`no pass generated by this node`);
	// 	}
	// }
}
