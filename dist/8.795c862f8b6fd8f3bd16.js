(window.webpackJsonpPOLY=window.webpackJsonpPOLY||[]).push([[8],{478:function(e,t,s){"use strict";s.r(t),s.d(t,"OBJLoader2",(function(){return w}));var n=s(65),a=s(28),o=s(11);const i=function(){this.logging={enabled:!1,debug:!1};const e=this;this.callbacks={onProgress:function(t){e._onProgress(t)},onAssetAvailable:function(t){e._onAssetAvailable(t)},onError:function(t){e._onError(t)},onLoad:function(t,s){e._onLoad(t,s)}},this.contentRef=null,this.legacyMode=!1,this.materials={},this.materialPerSmoothingGroup=!1,this.useOAsMesh=!1,this.useIndices=!1,this.disregardNormals=!1,this.vertices=[],this.colors=[],this.normals=[],this.uvs=[],this.rawMesh={objectName:"",groupName:"",activeMtlName:"",mtllibName:"",faceType:-1,subGroups:[],subGroupInUse:null,smoothingGroup:{splitMaterials:!1,normalized:-1,real:-1},counts:{doubleIndicesCount:0,faceCount:0,mtlCount:0,smoothingGroupCount:0}},this.inputObjectCount=1,this.outputObjectCount=1,this.globalCounts={vertices:0,faces:0,doubleIndicesCount:0,lineByte:0,currentByte:0,totalBytes:0}};i.prototype={constructor:i,_resetRawMesh:function(){this.rawMesh.subGroups=[],this.rawMesh.subGroupInUse=null,this.rawMesh.smoothingGroup.normalized=-1,this.rawMesh.smoothingGroup.real=-1,this._pushSmoothingGroup(1),this.rawMesh.counts.doubleIndicesCount=0,this.rawMesh.counts.faceCount=0,this.rawMesh.counts.mtlCount=0,this.rawMesh.counts.smoothingGroupCount=0},setMaterialPerSmoothingGroup:function(e){return this.materialPerSmoothingGroup=!0===e,this},setUseOAsMesh:function(e){return this.useOAsMesh=!0===e,this},setUseIndices:function(e){return this.useIndices=!0===e,this},setDisregardNormals:function(e){return this.disregardNormals=!0===e,this},setMaterials:function(e){this.materials=Object.assign({},e)},setCallbackOnAssetAvailable:function(e){return null!=e&&e instanceof Function&&(this.callbacks.onAssetAvailable=e),this},setCallbackOnProgress:function(e){return null!=e&&e instanceof Function&&(this.callbacks.onProgress=e),this},setCallbackOnError:function(e){return null!=e&&e instanceof Function&&(this.callbacks.onError=e),this},setCallbackOnLoad:function(e){return null!=e&&e instanceof Function&&(this.callbacks.onLoad=e),this},_onProgress:function(e){const t=e||"";this.logging.enabled&&this.logging.debug&&console.log(t)},_onError:function(e){this.logging.enabled&&this.logging.debug&&console.error(e)},_onAssetAvailable:function(){const e="OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...";throw this.callbacks.onError(e),e},_onLoad:function(e,t){console.log("You reached parser default onLoad callback: "+t)},setLogging:function(e,t){return this.logging.enabled=!0===e,this.logging.debug=!0===t,this},_configure:function(){if(this._pushSmoothingGroup(1),this.logging.enabled){const e=Object.keys(this.materials);let t="OBJLoader.Parser configuration:"+(e.length>0?"\n\tmaterialNames:\n\t\t- "+e.join("\n\t\t- "):"\n\tmaterialNames: None")+"\n\tmaterialPerSmoothingGroup: "+this.materialPerSmoothingGroup+"\n\tuseOAsMesh: "+this.useOAsMesh+"\n\tuseIndices: "+this.useIndices+"\n\tdisregardNormals: "+this.disregardNormals;t+="\n\tcallbacks.onProgress: "+this.callbacks.onProgress.name,t+="\n\tcallbacks.onAssetAvailable: "+this.callbacks.onAssetAvailable.name,t+="\n\tcallbacks.onError: "+this.callbacks.onError.name,console.info(t)}},execute:function(e){this.logging.enabled&&console.time("OBJLoader2Parser.execute"),this._configure();const t=new Uint8Array(e);this.contentRef=t;const s=t.byteLength;this.globalCounts.totalBytes=s;const n=new Array(128);let a,o=0,i=0,r="",l=0;for(;l<s;l++)switch(a=t[l],a){case 32:r.length>0&&(n[o++]=r),r="";break;case 47:r.length>0&&(n[o++]=r),i++,r="";break;case 10:this._processLine(n,o,i,r,l),r="",o=0,i=0;break;case 13:break;default:r+=String.fromCharCode(a)}this._processLine(n,o,i,r,l),this._finalizeParsing(),this.logging.enabled&&console.timeEnd("OBJLoader2Parser.execute")},executeLegacy:function(e){this.logging.enabled&&console.time("OBJLoader2Parser.executeLegacy"),this._configure(),this.legacyMode=!0,this.contentRef=e;const t=e.length;this.globalCounts.totalBytes=t;const s=new Array(128);let n,a=0,o=0,i="",r=0;for(;r<t;r++)switch(n=e[r],n){case" ":i.length>0&&(s[a++]=i),i="";break;case"/":i.length>0&&(s[a++]=i),o++,i="";break;case"\n":this._processLine(s,a,o,i,r),i="",a=0,o=0;break;case"\r":break;default:i+=n}this._processLine(s,a,i,o),this._finalizeParsing(),this.logging.enabled&&console.timeEnd("OBJLoader2Parser.executeLegacy")},_processLine:function(e,t,s,n,a){if(this.globalCounts.lineByte=this.globalCounts.currentByte,this.globalCounts.currentByte=a,t<1)return;n.length>0&&(e[t++]=n);const o=function(e,t,s,n){let a="";if(n>s){let o;if(t)for(o=s;o<n;o++)a+=e[o];else for(o=s;o<n;o++)a+=String.fromCharCode(e[o]);a=a.trim()}return a};let i,r,l;const c=e[0];switch(c){case"v":this.vertices.push(parseFloat(e[1])),this.vertices.push(parseFloat(e[2])),this.vertices.push(parseFloat(e[3])),t>4&&(this.colors.push(parseFloat(e[4])),this.colors.push(parseFloat(e[5])),this.colors.push(parseFloat(e[6])));break;case"vt":this.uvs.push(parseFloat(e[1])),this.uvs.push(parseFloat(e[2]));break;case"vn":this.normals.push(parseFloat(e[1])),this.normals.push(parseFloat(e[2])),this.normals.push(parseFloat(e[3]));break;case"f":if(i=t-1,0===s)for(this._checkFaceType(0),l=2,r=i;l<r;l++)this._buildFace(e[1]),this._buildFace(e[l]),this._buildFace(e[l+1]);else if(i===2*s)for(this._checkFaceType(1),l=3,r=i-2;l<r;l+=2)this._buildFace(e[1],e[2]),this._buildFace(e[l],e[l+1]),this._buildFace(e[l+2],e[l+3]);else if(2*i==3*s)for(this._checkFaceType(2),l=4,r=i-3;l<r;l+=3)this._buildFace(e[1],e[2],e[3]),this._buildFace(e[l],e[l+1],e[l+2]),this._buildFace(e[l+3],e[l+4],e[l+5]);else for(this._checkFaceType(3),l=3,r=i-2;l<r;l+=2)this._buildFace(e[1],void 0,e[2]),this._buildFace(e[l],void 0,e[l+1]),this._buildFace(e[l+2],void 0,e[l+3]);break;case"l":case"p":if(i=t-1,i===2*s)for(this._checkFaceType(4),l=1,r=i+1;l<r;l+=2)this._buildFace(e[l],e[l+1]);else for(this._checkFaceType("l"===c?5:6),l=1,r=i+1;l<r;l++)this._buildFace(e[l]);break;case"s":this._pushSmoothingGroup(e[1]);break;case"g":this._processCompletedMesh(),this.rawMesh.groupName=o(this.contentRef,this.legacyMode,this.globalCounts.lineByte+2,this.globalCounts.currentByte);break;case"o":this.useOAsMesh&&this._processCompletedMesh(),this.rawMesh.objectName=o(this.contentRef,this.legacyMode,this.globalCounts.lineByte+2,this.globalCounts.currentByte);break;case"mtllib":this.rawMesh.mtllibName=o(this.contentRef,this.legacyMode,this.globalCounts.lineByte+7,this.globalCounts.currentByte);break;case"usemtl":const n=o(this.contentRef,this.legacyMode,this.globalCounts.lineByte+7,this.globalCounts.currentByte);""!==n&&this.rawMesh.activeMtlName!==n&&(this.rawMesh.activeMtlName=n,this.rawMesh.counts.mtlCount++,this._checkSubGroup())}},_pushSmoothingGroup:function(e){let t=parseInt(e);isNaN(t)&&(t="off"===e?0:1);const s=this.rawMesh.smoothingGroup.normalized;this.rawMesh.smoothingGroup.normalized=this.rawMesh.smoothingGroup.splitMaterials?t:0===t?0:1,this.rawMesh.smoothingGroup.real=t,s!==t&&(this.rawMesh.counts.smoothingGroupCount++,this._checkSubGroup())},_checkFaceType:function(e){this.rawMesh.faceType!==e&&(this._processCompletedMesh(),this.rawMesh.faceType=e,this._checkSubGroup())},_checkSubGroup:function(){const e=this.rawMesh.activeMtlName+"|"+this.rawMesh.smoothingGroup.normalized;this.rawMesh.subGroupInUse=this.rawMesh.subGroups[e],void 0!==this.rawMesh.subGroupInUse&&null!==this.rawMesh.subGroupInUse||(this.rawMesh.subGroupInUse={index:e,objectName:this.rawMesh.objectName,groupName:this.rawMesh.groupName,materialName:this.rawMesh.activeMtlName,smoothingGroup:this.rawMesh.smoothingGroup.normalized,vertices:[],indexMappingsCount:0,indexMappings:[],indices:[],colors:[],uvs:[],normals:[]},this.rawMesh.subGroups[e]=this.rawMesh.subGroupInUse)},_buildFace:function(e,t,s){const n=this.rawMesh.subGroupInUse,a=this,o=function(){const o=parseInt(e);let i=3*(o>0?o-1:o+a.vertices.length/3),r=a.colors.length>0?i:null;const l=n.vertices;if(l.push(a.vertices[i++]),l.push(a.vertices[i++]),l.push(a.vertices[i]),null!==r){const e=n.colors;e.push(a.colors[r++]),e.push(a.colors[r++]),e.push(a.colors[r])}if(t){const e=parseInt(t);let s=2*(e>0?e-1:e+a.uvs.length/2);const o=n.uvs;o.push(a.uvs[s++]),o.push(a.uvs[s])}if(s&&!a.disregardNormals){const e=parseInt(s);let t=3*(e>0?e-1:e+a.normals.length/3);const o=n.normals;o.push(a.normals[t++]),o.push(a.normals[t++]),o.push(a.normals[t])}};if(this.useIndices){this.disregardNormals&&(s=void 0);const a=e+(t?"_"+t:"_n")+(s?"_"+s:"_n");let i=n.indexMappings[a];null==i?(i=this.rawMesh.subGroupInUse.vertices.length/3,o(),n.indexMappings[a]=i,n.indexMappingsCount++):this.rawMesh.counts.doubleIndicesCount++,n.indices.push(i)}else o();this.rawMesh.counts.faceCount++},_createRawMeshReport:function(e){return"Input Object number: "+e+"\n\tObject name: "+this.rawMesh.objectName+"\n\tGroup name: "+this.rawMesh.groupName+"\n\tMtllib name: "+this.rawMesh.mtllibName+"\n\tVertex count: "+this.vertices.length/3+"\n\tNormal count: "+this.normals.length/3+"\n\tUV count: "+this.uvs.length/2+"\n\tSmoothingGroup count: "+this.rawMesh.counts.smoothingGroupCount+"\n\tMaterial count: "+this.rawMesh.counts.mtlCount+"\n\tReal MeshOutputGroup count: "+this.rawMesh.subGroups.length},_finalizeRawMesh:function(){const e=[];let t,s,n=0,a=0,o=0,i=0,r=0,l=0;for(const c in this.rawMesh.subGroups)if(t=this.rawMesh.subGroups[c],t.vertices.length>0){if(s=t.indices,s.length>0&&a>0)for(let e=0;e<s.length;e++)s[e]=s[e]+a;e.push(t),n+=t.vertices.length,a+=t.indexMappingsCount,o+=t.indices.length,i+=t.colors.length,l+=t.uvs.length,r+=t.normals.length}let c=null;return e.length>0&&(c={name:""!==this.rawMesh.groupName?this.rawMesh.groupName:this.rawMesh.objectName,subGroups:e,absoluteVertexCount:n,absoluteIndexCount:o,absoluteColorCount:i,absoluteNormalCount:r,absoluteUvCount:l,faceCount:this.rawMesh.counts.faceCount,doubleIndicesCount:this.rawMesh.counts.doubleIndicesCount}),c},_processCompletedMesh:function(){const e=this._finalizeRawMesh(),t=null!==e;if(t){this.colors.length>0&&this.colors.length!==this.vertices.length&&this.callbacks.onError("Vertex Colors were detected, but vertex count and color count do not match!"),this.logging.enabled&&this.logging.debug&&console.debug(this._createRawMeshReport(this.inputObjectCount)),this.inputObjectCount++,this._buildMesh(e);const t=this.globalCounts.currentByte/this.globalCounts.totalBytes;this._onProgress("Completed [o: "+this.rawMesh.objectName+" g:"+this.rawMesh.groupName+"] Total progress: "+(100*t).toFixed(2)+"%"),this._resetRawMesh()}return t},_buildMesh:function(e){const t=e.subGroups,s=new Float32Array(e.absoluteVertexCount);this.globalCounts.vertices+=e.absoluteVertexCount/3,this.globalCounts.faces+=e.faceCount,this.globalCounts.doubleIndicesCount+=e.doubleIndicesCount;const n=e.absoluteIndexCount>0?new Uint32Array(e.absoluteIndexCount):null,a=e.absoluteColorCount>0?new Float32Array(e.absoluteColorCount):null,o=e.absoluteNormalCount>0?new Float32Array(e.absoluteNormalCount):null,i=e.absoluteUvCount>0?new Float32Array(e.absoluteUvCount):null,r=null!==a;let l;const c=[],h=t.length>1;let u=0;const g=[];let d,b;const m=[];let p,f,M,w,C=0,v=0,y=0,k=0,A=0,_=0,O=0;for(const e in t)if(t.hasOwnProperty(e)){if(l=t[e],w=l.materialName,M=this.rawMesh.faceType<4?w+(r?"_vertexColor":"")+(0===l.smoothingGroup?"_flat":""):6===this.rawMesh.faceType?"defaultPointMaterial":"defaultLineMaterial",p=this.materials[w],f=this.materials[M],null==p&&null==f&&(M=r?"defaultVertexColorMaterial":"defaultMaterial",f=this.materials[M],this.logging.enabled&&console.info('object_group "'+l.objectName+"_"+l.groupName+'" was defined with unresolvable material "'+w+'"! Assigning "'+M+'".')),null==f){const e={materialNameOrg:w,materialName:M,materialProperties:{vertexColors:r?2:0,flatShading:0===l.smoothingGroup}},t={cmd:"assetAvailable",type:"material",materials:{materialCloneInstructions:e}};this.callbacks.onAssetAvailable(t);const s=this.materials[M];null==s&&(this.materials[M]=e)}if(h?(d=g[M],d||(d=u,g[M]=u,c.push(M),u++),O=this.useIndices?l.indices.length:l.vertices.length/3,b={start:_,count:O,index:d},m.push(b),_+=O):c.push(M),s.set(l.vertices,C),C+=l.vertices.length,n&&(n.set(l.indices,v),v+=l.indices.length),a&&(a.set(l.colors,y),y+=l.colors.length),o&&(o.set(l.normals,k),k+=l.normals.length),i&&(i.set(l.uvs,A),A+=l.uvs.length),this.logging.enabled&&this.logging.debug){let e="";d&&(e="\n\t\tmaterialIndex: "+d);const t="\tOutput Object no.: "+this.outputObjectCount+"\n\t\tgroupName: "+l.groupName+"\n\t\tIndex: "+l.index+"\n\t\tfaceType: "+this.rawMesh.faceType+"\n\t\tmaterialName: "+l.materialName+"\n\t\tsmoothingGroup: "+l.smoothingGroup+e+"\n\t\tobjectName: "+l.objectName+"\n\t\t#vertices: "+l.vertices.length/3+"\n\t\t#indices: "+l.indices.length+"\n\t\t#colors: "+l.colors.length/3+"\n\t\t#uvs: "+l.uvs.length/2+"\n\t\t#normals: "+l.normals.length/3;console.debug(t)}}this.outputObjectCount++,this.callbacks.onAssetAvailable({cmd:"assetAvailable",type:"mesh",progress:{numericalValue:this.globalCounts.currentByte/this.globalCounts.totalBytes},params:{meshName:e.name},materials:{multiMaterial:h,materialNames:c,materialGroups:m},buffers:{vertices:s,indices:n,colors:a,normals:o,uvs:i},geometryType:this.rawMesh.faceType<4?0:6===this.rawMesh.faceType?2:1},[s.buffer],null!==n?[n.buffer]:null,null!==a?[a.buffer]:null,null!==o?[o.buffer]:null,null!==i?[i.buffer]:null)},_finalizeParsing:function(){if(this.logging.enabled&&console.info("Global output object count: "+this.outputObjectCount),this._processCompletedMesh()&&this.logging.enabled){const e="Overall counts: \n\tVertices: "+this.globalCounts.vertices+"\n\tFaces: "+this.globalCounts.faces+"\n\tMultiple definitions: "+this.globalCounts.doubleIndicesCount;console.info(e)}}};var r=s(3),l=s(5),c=s(35),h=s(17),u=s(51);const g=function(e){this.logging={enabled:!1,debug:!1},this.callbacks={onProgress:null,onMeshAlter:null},this.materialHandler=e};g.prototype={constructor:g,setLogging:function(e,t){this.logging.enabled=!0===e,this.logging.debug=!0===t},_setCallbacks:function(e,t){null!=e&&e instanceof Function&&(this.callbacks.onProgress=e),null!=t&&t instanceof Function&&(this.callbacks.onMeshAlter=t)},buildMeshes:function(e){const t=e.params.meshName,s=e.buffers,n=new l.a;let a,o,i;void 0!==s.vertices&&null!==s.vertices&&n.setAttribute("position",new r.a(new Float32Array(s.vertices),3)),void 0!==s.indices&&null!==s.indices&&n.setIndex(new r.a(new Uint32Array(s.indices),1)),void 0!==s.colors&&null!==s.colors&&n.setAttribute("color",new r.a(new Float32Array(s.colors),3)),void 0!==s.normals&&null!==s.normals?n.setAttribute("normal",new r.a(new Float32Array(s.normals),3)):n.computeVertexNormals(),void 0!==s.uvs&&null!==s.uvs&&n.setAttribute("uv",new r.a(new Float32Array(s.uvs),2)),void 0!==s.skinIndex&&null!==s.skinIndex&&n.setAttribute("skinIndex",new r.a(new Uint16Array(s.skinIndex),4)),void 0!==s.skinWeight&&null!==s.skinWeight&&n.setAttribute("skinWeight",new r.a(new Float32Array(s.skinWeight),4));const g=e.materials.materialNames,d=e.materials.multiMaterial,b=[];for(i in g)o=g[i],a=this.materialHandler.getMaterial(o),d&&b.push(a);if(d){a=b;const t=e.materials.materialGroups;let s;for(i in t)s=t[i],n.addGroup(s.start,s.count,s.index)}const m=[];let p,f,M=!0;const w=null===e.geometryType?0:e.geometryType;if(this.callbacks.onMeshAlter&&(f=this.callbacks.onMeshAlter({detail:{meshName:t,bufferGeometry:n,material:a,geometryType:w}})),f)if(f.isDisregardMesh())M=!1;else if(f.providesAlteredMeshes()){for(const e in f.meshes)m.push(f.meshes[e]);M=!1}M&&(e.computeBoundingSphere&&n.computeBoundingSphere(),p=0===w?new h.a(n,a):1===w?new c.a(n,a):new u.a(n,a),p.name=t,m.push(p));let C=e.params.meshName;if(m.length>0){const s=[];for(const e in m)p=m[e],s[e]=p.name;C+=": Adding mesh(es) ("+s.length+": "+s+") from input mesh: "+t,C+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)"}else C+=": Not adding mesh: "+t,C+=" ("+(100*e.progress.numericalValue).toFixed(2)+"%)";return this.callbacks.onProgress&&this.callbacks.onProgress("progress",C,e.progress.numericalValue),m}};const d=function(e,t){this.disregardMesh=!0===e,this.alteredMesh=!0===t,this.meshes=[]};d.prototype={constructor:d,addMesh:function(e){this.meshes.push(e),this.alteredMesh=!0},isDisregardMesh:function(){return this.disregardMesh},providesAlteredMeshes:function(){return this.alteredMesh}};var b=s(29),m=s(134),p=s(59),f=s(58);const M=function(){this.logging={enabled:!1,debug:!1},this.callbacks={onLoadMaterials:null},this.materials={}};M.prototype={constructor:M,setLogging:function(e,t){this.logging.enabled=!0===e,this.logging.debug=!0===t},_setCallbacks:function(e){null!=e&&e instanceof Function&&(this.callbacks.onLoadMaterials=e)},createDefaultMaterials:function(e){const t=new p.a({color:14479871});t.name="defaultMaterial";const s=new p.a({color:14479871});s.name="defaultVertexColorMaterial",s.vertexColors=!0;const n=new b.a;n.name="defaultLineMaterial";const a=new f.a({size:.1});a.name="defaultPointMaterial";const o={};o[t.name]=t,o[s.name]=s,o[n.name]=n,o[a.name]=a,this.addMaterials(o,e)},addPayloadMaterials:function(e){let t,s;const n=e.materials.materialCloneInstructions;let a={};if(null!=n){let e=n.materialNameOrg;e=null!=e?e:"";const o=this.materials[e];o?(t=o.clone(),s=n.materialName,t.name=s,Object.assign(t,n.materialProperties),this.materials[s]=t,a[s]=t):this.logging.enabled&&console.info('Requested material "'+e+'" is not available!')}let o=e.materials.serializedMaterials;if(null!=o&&Object.keys(o).length>0){const e=new m.a;let n;for(s in o)n=o[s],null!=n&&(t=e.parse(n),this.logging.enabled&&console.info('De-serialized material with name "'+s+'" will be added.'),this.materials[s]=t,a[s]=t)}return o=e.materials.runtimeMaterials,a=this.addMaterials(o,!0,a),a},addMaterials:function(e,t,s){if(null==s&&(s={}),null!=e&&Object.keys(e).length>0){let n,a,o;for(const i in e)n=e[i],o=!0===t,o||(a=this.materials[i],o=null==a),o&&(this.materials[i]=n,s[i]=n),this.logging.enabled&&this.logging.debug&&console.info('Material with name "'+i+'" was added.')}return this.callbacks.onLoadMaterials&&this.callbacks.onLoadMaterials(s),s},getMaterials:function(){return this.materials},getMaterial:function(e){return this.materials[e]},getMaterialsJSON:function(){const e={};let t;for(const s in this.materials)t=this.materials[s],e[s]=t.toJSON();return e},clearMaterials:function(){this.materials={}}};const w=function(e){a.a.call(this,e),this.parser=new i,this.modelName="",this.instanceNo=0,this.baseObject3d=new o.a,this.materialHandler=new M,this.meshReceiver=new g(this.materialHandler);const t=this;this.parser.setCallbackOnAssetAvailable((function(e){t._onAssetAvailable(e)}))};w.OBJLOADER2_VERSION="3.2.0",console.info("Using OBJLoader2 version: "+w.OBJLOADER2_VERSION),w.prototype=Object.assign(Object.create(a.a.prototype),{constructor:w,setLogging:function(e,t){return this.parser.setLogging(e,t),this},setMaterialPerSmoothingGroup:function(e){return this.parser.setMaterialPerSmoothingGroup(e),this},setUseOAsMesh:function(e){return this.parser.setUseOAsMesh(e),this},setUseIndices:function(e){return this.parser.setUseIndices(e),this},setDisregardNormals:function(e){return this.parser.setDisregardNormals(e),this},setModelName:function(e){return this.modelName=e||this.modelName,this},setBaseObject3d:function(e){return this.baseObject3d=null==e?this.baseObject3d:e,this},addMaterials:function(e,t){return this.materialHandler.addMaterials(e,t),this},setCallbackOnAssetAvailable:function(e){return this.parser.setCallbackOnAssetAvailable(e),this},setCallbackOnProgress:function(e){return this.parser.setCallbackOnProgress(e),this},setCallbackOnError:function(e){return this.parser.setCallbackOnError(e),this},setCallbackOnLoad:function(e){return this.parser.setCallbackOnLoad(e),this},setCallbackOnMeshAlter:function(e){return this.meshReceiver._setCallbacks(this.parser.callbacks.onProgress,e),this},setCallbackOnLoadMaterials:function(e){return this.materialHandler._setCallbacks(e),this},load:function(e,t,s,a,o){const i=this;if(!(null!=t&&t instanceof Function)){const e="onLoad is not a function! Aborting...";throw i.parser.callbacks.onError(e),e}this.parser.setCallbackOnLoad(t),null!=a&&a instanceof Function||(a=function(e){let t=e;e.currentTarget&&null!==e.currentTarget.statusText&&(t="Error occurred while downloading!\nurl: "+e.currentTarget.responseURL+"\nstatus: "+e.currentTarget.statusText),i.parser.callbacks.onError(t)}),e||a("An invalid url was provided. Unable to continue!");const r=new URL(e,window.location.href).href;let l=r;const c=r.split("/");if(c.length>2&&(l=c[c.length-1],this.path=c.slice(0,c.length-1).join("/")+"/"),null==s||!(s instanceof Function)){let t=0,n=0;s=function(s){if(s.lengthComputable&&(n=s.loaded/s.total,n>t)){t=n;const s='Download of "'+e+'": '+(100*n).toFixed(2)+"%";i.parser.callbacks.onProgress("progressLoad",s,n)}}}this.setCallbackOnMeshAlter(o);const h=new n.a(this.manager);h.setPath(this.path||this.resourcePath),h.setResponseType("arraybuffer"),h.load(l,(function(e){i.parser.callbacks.onLoad(i.parse(e),"OBJLoader2#load: Parsing completed")}),s,a)},parse:function(e){if(null==e)throw"Provided content is not a valid ArrayBuffer or String. Unable to continue parsing";return this.parser.logging.enabled&&console.time("OBJLoader parse: "+this.modelName),this.materialHandler.createDefaultMaterials(!1),this.parser.setMaterials(this.materialHandler.getMaterials()),e instanceof ArrayBuffer||e instanceof Uint8Array?(this.parser.logging.enabled&&console.info("Parsing arrayBuffer..."),this.parser.execute(e)):"string"==typeof e||e instanceof String?(this.parser.logging.enabled&&console.info("Parsing text..."),this.parser.executeLegacy(e)):this.parser.callbacks.onError("Provided content was neither of type String nor Uint8Array! Aborting..."),this.parser.logging.enabled&&console.timeEnd("OBJLoader parse: "+this.modelName),this.baseObject3d},_onAssetAvailable:function(e){if("assetAvailable"===e.cmd)if("mesh"===e.type){const t=this.meshReceiver.buildMeshes(e);for(const e of t)this.baseObject3d.add(e)}else"material"===e.type&&this.materialHandler.addPayloadMaterials(e)}})}}]);
//# sourceMappingURL=8.795c862f8b6fd8f3bd16.js.map