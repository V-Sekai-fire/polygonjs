import { ShaderName } from './ShaderName';
import { TypedNode, BaseNodeType } from '../../_Base';
import { NodeContext } from '../../../poly/NodeContext';
import { NodeTypeMap } from '../../../containers/utils/ContainerMap';
import { CoreGraphNodeId } from '../../../../core/graph/CoreGraph';
declare type InputNamesByShaderNameMethod<NC extends NodeContext> = (root_node: NodeTypeMap[NC], shader_name: ShaderName) => string[];
export declare class TypedNodeTraverser<NC extends NodeContext> {
    private _parent_node;
    private _shader_names;
    private _input_names_for_shader_name_method;
    private _leaves_graph_id;
    private _graph_ids_by_shader_name;
    private _outputs_by_graph_id;
    private _depth_by_graph_id;
    private _graph_id_by_depth;
    private _graph;
    private _shader_name;
    constructor(_parent_node: TypedNode<NC, any>, _shader_names: ShaderName[], _input_names_for_shader_name_method: InputNamesByShaderNameMethod<NC>);
    private reset;
    shader_names(): ShaderName[];
    input_names_for_shader_name(root_node: NodeTypeMap[NC], shader_name: ShaderName): string[];
    traverse(root_nodes: NodeTypeMap[NC][]): void;
    leaves_from_nodes(nodes: NodeTypeMap[NC][]): NodeTypeMap[NC][];
    nodes_for_shader_name(shader_name: ShaderName): NodeTypeMap[NC][];
    sorted_nodes(): NodeTypeMap[NC][];
    add_nodes_with_children(node: NodeTypeMap[NC], node_id_used_state: Map<CoreGraphNodeId, boolean>, accumulated_nodes: NodeTypeMap[NC][], shader_name?: ShaderName): void;
    sorted_nodes_for_shader_name_for_parent(parent: BaseNodeType, shader_name?: ShaderName): NodeTypeMap[NC][];
    private find_leaves_from_root_node;
    private find_leaves;
    private _find_inputs_or_children;
    private set_nodes_depth;
    private set_node_depth;
}
export {};
