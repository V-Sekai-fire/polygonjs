{"version":3,"sources":["webpack://POLY/./src/modules/three/examples/jsm/loaders/obj2/OBJLoader2Parser.js","webpack://POLY/./src/modules/three/examples/jsm/loaders/obj2/shared/MeshReceiver.js","webpack://POLY/./src/modules/three/examples/jsm/loaders/obj2/shared/MaterialHandler.js","webpack://POLY/./src/modules/three/examples/jsm/loaders/OBJLoader2.js"],"names":["OBJLoader2Parser","this","logging","enabled","debug","scope","callbacks","onProgress","text","_onProgress","onAssetAvailable","payload","_onAssetAvailable","onError","errorMessage","_onError","onLoad","object3d","message","_onLoad","contentRef","legacyMode","materials","materialPerSmoothingGroup","useOAsMesh","useIndices","disregardNormals","vertices","colors","normals","uvs","rawMesh","objectName","groupName","activeMtlName","mtllibName","faceType","subGroups","subGroupInUse","smoothingGroup","splitMaterials","normalized","real","counts","doubleIndicesCount","faceCount","mtlCount","smoothingGroupCount","inputObjectCount","outputObjectCount","globalCounts","faces","lineByte","currentByte","totalBytes","prototype","constructor","_resetRawMesh","_pushSmoothingGroup","setMaterialPerSmoothingGroup","setUseOAsMesh","setUseIndices","setDisregardNormals","setMaterials","Object","assign","setCallbackOnAssetAvailable","Function","setCallbackOnProgress","setCallbackOnError","setCallbackOnLoad","console","log","error","setLogging","_configure","matKeys","keys","printedConfig","length","join","name","info","execute","arrayBuffer","time","arrayBufferView","Uint8Array","byteLength","buffer","Array","code","bufferPointer","slashesCount","word","_processLine","String","fromCharCode","_finalizeParsing","timeEnd","executeLegacy","char","reconstructString","content","start","stop","line","i","trim","bufferLength","lineDesignation","push","parseFloat","_checkFaceType","_buildFace","undefined","_processCompletedMesh","mtlName","_checkSubGroup","smoothingGroupInt","parseInt","isNaN","smoothCheck","index","materialName","indexMappingsCount","indexMappings","indices","faceIndexV","faceIndexU","faceIndexN","updateSubGroupInUse","faceIndexVi","indexPointerV","indexPointerC","faceIndexUi","indexPointerU","faceIndexNi","indexPointerN","mappingName","indicesPointer","_createRawMeshReport","_finalizeRawMesh","meshOutputGroupTemp","meshOutputGroup","absoluteVertexCount","absoluteIndexMappingsCount","absoluteIndexCount","absoluteColorCount","absoluteNormalCount","absoluteUvCount","result","haveMesh","_buildMesh","progressBytesPercent","toFixed","meshOutputGroups","vertexFA","Float32Array","indexUA","Uint32Array","colorFA","normalFA","uvFA","haveVertexColors","materialNames","createMultiMaterial","materialIndex","materialIndexMapping","selectedMaterialIndex","materialGroup","materialGroups","materialOrg","material","materialNameOrg","vertexFAOffset","indexUAOffset","colorFAOffset","normalFAOffset","uvFAOffset","materialGroupOffset","materialGroupLength","oodIndex","hasOwnProperty","materialCloneInstructions","materialProperties","vertexColors","flatShading","cmd","type","matCheck","count","set","materialIndexLine","createdReport","progress","numericalValue","params","meshName","multiMaterial","buffers","geometryType","parserFinalReport","MeshReceiver","materialHandler","onMeshAlter","_setCallbacks","buildMeshes","meshPayload","bufferGeometry","BufferGeometry","key","setAttribute","BufferAttribute","setIndex","computeVertexNormals","skinIndex","Uint16Array","skinWeight","multiMaterials","getMaterial","addGroup","meshes","mesh","callbackOnMeshAlterResult","useOrgMesh","detail","isDisregardMesh","providesAlteredMeshes","computeBoundingSphere","Mesh","LineSegments","Points","progressMessage","meshNames","LoadedMeshUserOverride","disregardMesh","alteredMesh","addMesh","MaterialHandler","onLoadMaterials","createDefaultMaterials","overrideExisting","defaultMaterial","MeshStandardMaterial","color","defaultVertexColorMaterial","defaultLineMaterial","LineBasicMaterial","defaultPointMaterial","PointsMaterial","size","runtimeMaterials","addMaterials","addPayloadMaterials","materialPayload","newMaterials","clone","serializedMaterials","loader","MaterialLoader","materialJson","parse","existingMaterial","add","getMaterials","getMaterialsJSON","materialsJSON","toJSON","clearMaterials","OBJLoader2","manager","Loader","call","parser","modelName","instanceNo","baseObject3d","Object3D","meshReceiver","OBJLOADER2_VERSION","create","setModelName","setBaseObject3d","setCallbackOnMeshAlter","setCallbackOnLoadMaterials","load","url","onFileLoadProgress","event","currentTarget","statusText","responseURL","urlFull","URL","window","location","href","filename","urlParts","split","path","slice","numericalValueRef","lengthComputable","loaded","total","output","fileLoader","FileLoader","setPath","resourcePath","setResponseType","ArrayBuffer"],"mappings":"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","file":"8.js","sourcesContent":["/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nconst OBJLoader2Parser = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tconst scope = this;\n\tthis.callbacks = {\n\t\tonProgress: function ( text ) {\n\n\t\t\tscope._onProgress( text );\n\n\t\t},\n\t\tonAssetAvailable: function ( payload ) {\n\n\t\t\tscope._onAssetAvailable( payload );\n\n\t\t},\n\t\tonError: function ( errorMessage ) {\n\n\t\t\tscope._onError( errorMessage );\n\n\t\t},\n\t\tonLoad: function ( object3d, message ) {\n\n\t\t\tscope._onLoad( object3d, message );\n\n\t\t},\n\t};\n\tthis.contentRef = null;\n\tthis.legacyMode = false;\n\n\tthis.materials = {};\n\tthis.materialPerSmoothingGroup = false;\n\tthis.useOAsMesh = false;\n\tthis.useIndices = false;\n\tthis.disregardNormals = false;\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.normals = [];\n\tthis.uvs = [];\n\n\tthis.rawMesh = {\n\t\tobjectName: '',\n\t\tgroupName: '',\n\t\tactiveMtlName: '',\n\t\tmtllibName: '',\n\n\t\t// reset with new mesh\n\t\tfaceType: - 1,\n\t\tsubGroups: [],\n\t\tsubGroupInUse: null,\n\t\tsmoothingGroup: {\n\t\t\tsplitMaterials: false,\n\t\t\tnormalized: - 1,\n\t\t\treal: - 1\n\t\t},\n\t\tcounts: {\n\t\t\tdoubleIndicesCount: 0,\n\t\t\tfaceCount: 0,\n\t\t\tmtlCount: 0,\n\t\t\tsmoothingGroupCount: 0\n\t\t}\n\t};\n\n\tthis.inputObjectCount = 1;\n\tthis.outputObjectCount = 1;\n\tthis.globalCounts = {\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tdoubleIndicesCount: 0,\n\t\tlineByte: 0,\n\t\tcurrentByte: 0,\n\t\ttotalBytes: 0\n\t};\n\n};\n\nOBJLoader2Parser.prototype = {\n\n\tconstructor: OBJLoader2Parser,\n\n\t_resetRawMesh: function () {\n\n\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\tthis.rawMesh.subGroups = [];\n\t\tthis.rawMesh.subGroupInUse = null;\n\t\tthis.rawMesh.smoothingGroup.normalized = - 1;\n\t\tthis.rawMesh.smoothingGroup.real = - 1;\n\n\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\tthis._pushSmoothingGroup( 1 );\n\n\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\tthis.rawMesh.counts.faceCount = 0;\n\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\n\t},\n\n\t/**\n\t * Tells whether a material shall be created per smoothing group.\n\t *\n\t * @param {boolean} materialPerSmoothingGroup=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n\t *\n\t * @param {boolean} useOAsMesh=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.useOAsMesh = useOAsMesh === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Instructs loaders to create indexed {@link BufferGeometry}.\n\t *\n\t * @param {boolean} useIndices=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.useIndices = useIndices === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Tells whether normals should be completely disregarded and regenerated.\n\t *\n\t * @param {boolean} disregardNormals=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.disregardNormals = disregardNormals === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Clears materials object and sets the new ones.\n\t *\n\t * @param {Object} materials Object with named materials\n\t */\n\tsetMaterials: function ( materials ) {\n\n \t\tthis.materials = Object.assign( {}, materials );\n\n\t},\n\n\t/**\n\t * Register a function that is called once an asset (mesh/material) becomes available.\n\t *\n\t * @param onAssetAvailable\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tif ( onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function ) {\n\n\t\t\tthis.callbacks.onAssetAvailable = onAssetAvailable;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is used to report overall processing progress.\n\t *\n\t * @param {Function} onProgress\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n\t *\n\t * @param {Function} onError\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tif ( onError !== null && onError !== undefined && onError instanceof Function ) {\n\n\t\t\tthis.callbacks.onError = onError;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called when parsing was completed.\n\t *\n\t * @param {Function} onLoad\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tif ( onLoad !== null && onLoad !== undefined && onLoad instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoad = onLoad;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Announce parse progress feedback which is logged to the console.\n\t * @private\n\t *\n\t * @param {string} text Textual description of the event\n\t */\n\t_onProgress: function ( text ) {\n\n\t\tconst message = text ? text : '';\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Announce error feedback which is logged as error message.\n\t * @private\n\t *\n\t * @param {String} errorMessage The event containing the error\n\t */\n\t_onError: function ( errorMessage ) {\n\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.error( errorMessage );\n\n\t\t}\n\n\t},\n\n\t_onAssetAvailable: function ( /*payload*/ ) {\n\n\t\tconst errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n\t\tthis.callbacks.onError( errorMessage );\n\t\tthrow errorMessage;\n\n\t},\n\n\t_onLoad: function ( object3d, message ) {\n\n\t\tconsole.log( \"You reached parser default onLoad callback: \" + message );\n\n\t},\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t *\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\treturn this;\n\n\t},\n\n\t_configure: function () {\n\n\t\tthis._pushSmoothingGroup( 1 );\n\t\tif ( this.logging.enabled ) {\n\n\t\t\tconst matKeys = Object.keys( this.materials );\n\t\t\tconst matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\n\t\t\tlet printedConfig = 'OBJLoader.Parser configuration:'\n\t\t\t\t+ matNames\n\t\t\t\t+ '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\n\t\t\t\t+ '\\n\\tuseOAsMesh: ' + this.useOAsMesh\n\t\t\t\t+ '\\n\\tuseIndices: ' + this.useIndices\n\t\t\t\t+ '\\n\\tdisregardNormals: ' + this.disregardNormals;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n\t\t\tconsole.info( printedConfig );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Parse the provided arraybuffer\n\t *\n\t * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n\t */\n\texecute: function ( arrayBuffer ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.execute' );\n\t\tthis._configure();\n\n\t\tconst arrayBufferView = new Uint8Array( arrayBuffer );\n\t\tthis.contentRef = arrayBufferView;\n\t\tconst length = arrayBufferView.byteLength;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tconst buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let code; currentByte < length; currentByte ++ ) {\n\n\t\t\tcode = arrayBufferView[ currentByte ];\n\t\t\tswitch ( code ) {\n\n\t\t\t\t// space\n\t\t\t\tcase 32:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\t\t\t\t// slash\n\t\t\t\tcase 47:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LF\n\t\t\t\tcase 10:\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// CR\n\t\t\t\tcase 13:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += String.fromCharCode( code );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.execute' );\n\n\t},\n\n\t/**\n\t * Parse the provided text\n\t *\n\t * @param {string} text OBJ data as string\n\t */\n\texecuteLegacy: function ( text ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.executeLegacy' );\n\t\tthis._configure();\n\t\tthis.legacyMode = true;\n\t\tthis.contentRef = text;\n\t\tconst length = text.length;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tconst buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let char; currentByte < length; currentByte ++ ) {\n\n\t\t\tchar = text[ currentByte ];\n\t\t\tswitch ( char ) {\n\n\t\t\t\tcase ' ':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '/':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\n':\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\r':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += char;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, word, slashesCount );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.executeLegacy' );\n\n\t},\n\n\t_processLine: function ( buffer, bufferPointer, slashesCount, word, currentByte ) {\n\n\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\tthis.globalCounts.currentByte = currentByte;\n\t\tif ( bufferPointer < 1 ) return;\n\n\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\n\t\tconst reconstructString = function ( content, legacyMode, start, stop ) {\n\n\t\t\tlet line = '';\n\t\t\tif ( stop > start ) {\n\n\t\t\t\tlet i;\n\t\t\t\tif ( legacyMode ) {\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += content[ i ];\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += String.fromCharCode( content[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tline = line.trim();\n\n\t\t\t}\n\n\t\t\treturn line;\n\n\t\t};\n\n\t\tlet bufferLength, length, i;\n\t\tconst lineDesignation = buffer[ 0 ];\n\t\tswitch ( lineDesignation ) {\n\n\t\t\tcase 'v':\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tif ( bufferPointer > 4 ) {\n\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 4 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 5 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 6 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'vt':\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'vn':\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t// \"f vertex ...\"\n\t\t\t\tif ( slashesCount === 0 ) {\n\n\t\t\t\t\tthis._checkFaceType( 0 );\n\t\t\t\t\tfor ( i = 2, length = bufferLength; i < length; i ++ ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv ...\"\n\n\t\t\t\t} else if ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 1 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\n\t\t\t\t} else if ( bufferLength * 2 === slashesCount * 3 ) {\n\n\t\t\t\t\tthis._checkFaceType( 2 );\n\t\t\t\t\tfor ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex//normal ...\"\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( 3 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\tcase 'p':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\tif ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 4 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i += 2 ) this._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i ++ ) this._buildFace( buffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tthis._pushSmoothingGroup( buffer[ 1 ] );\n\t\t\t\tbreak;\n\n\t\t\tcase 'g':\n\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\tthis._processCompletedMesh();\n\t\t\t\tthis.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'o':\n\t\t\t\t// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n\t\t\t\tif ( this.useOAsMesh ) this._processCompletedMesh();\n\t\t\t\tthis.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'mtllib':\n\t\t\t\tthis.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'usemtl':\n\t\t\t\tconst mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tif ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\n\n\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\tthis.rawMesh.counts.mtlCount ++;\n\t\t\t\t\tthis._checkSubGroup();\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\t_pushSmoothingGroup: function ( smoothingGroup ) {\n\n\t\tlet smoothingGroupInt = parseInt( smoothingGroup );\n\t\tif ( isNaN( smoothingGroupInt ) ) {\n\n\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\n\t\t}\n\n\t\tconst smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\n\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\tif ( smoothCheck !== smoothingGroupInt ) {\n\n\t\t\tthis.rawMesh.counts.smoothingGroupCount ++;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Expanded faceTypes include all four face types, both line types and the point type\n\t * faceType = 0: \"f vertex ...\"\n\t * faceType = 1: \"f vertex/uv ...\"\n\t * faceType = 2: \"f vertex/uv/normal ...\"\n\t * faceType = 3: \"f vertex//normal ...\"\n\t * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n\t * faceType = 5: \"l vertex ...\"\n\t * faceType = 6: \"p vertex ...\"\n\t */\n\t_checkFaceType: function ( faceType ) {\n\n\t\tif ( this.rawMesh.faceType !== faceType ) {\n\n\t\t\tthis._processCompletedMesh();\n\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t_checkSubGroup: function () {\n\n\t\tconst index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\n\n\t\tif ( this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null ) {\n\n\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\tindex: index,\n\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\tvertices: [],\n\t\t\t\tindexMappingsCount: 0,\n\t\t\t\tindexMappings: [],\n\t\t\t\tindices: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tnormals: []\n\t\t\t};\n\t\t\tthis.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\n\n\t\t}\n\n\t},\n\n\t_buildFace: function ( faceIndexV, faceIndexU, faceIndexN ) {\n\n\t\tconst subGroupInUse = this.rawMesh.subGroupInUse;\n\t\tconst scope = this;\n\t\tconst updateSubGroupInUse = function () {\n\n\t\t\tconst faceIndexVi = parseInt( faceIndexV );\n\t\t\tlet indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\n\t\t\tlet indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\n\t\t\tconst vertices = subGroupInUse.vertices;\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ] );\n\n\t\t\tif ( indexPointerC !== null ) {\n\n\t\t\t\tconst colors = subGroupInUse.colors;\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexU ) {\n\n\t\t\t\tconst faceIndexUi = parseInt( faceIndexU );\n\t\t\t\tlet indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\n\t\t\t\tconst uvs = subGroupInUse.uvs;\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ++ ] );\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexN && ! scope.disregardNormals ) {\n\n\t\t\t\tconst faceIndexNi = parseInt( faceIndexN );\n\t\t\t\tlet indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\n\t\t\t\tconst normals = subGroupInUse.normals;\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( this.useIndices ) {\n\n\t\t\tif ( this.disregardNormals ) faceIndexN = undefined;\n\t\t\tconst mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\n\t\t\tlet indicesPointer = subGroupInUse.indexMappings[ mappingName ];\n\t\t\tif ( indicesPointer === undefined || indicesPointer === null ) {\n\n\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t\tsubGroupInUse.indexMappings[ mappingName ] = indicesPointer;\n\t\t\t\tsubGroupInUse.indexMappingsCount ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.rawMesh.counts.doubleIndicesCount ++;\n\n\t\t\t}\n\n\t\t\tsubGroupInUse.indices.push( indicesPointer );\n\n\t\t} else {\n\n\t\t\tupdateSubGroupInUse();\n\n\t\t}\n\n\t\tthis.rawMesh.counts.faceCount ++;\n\n\t},\n\n\t_createRawMeshReport: function ( inputObjectCount ) {\n\n\t\treturn 'Input Object number: ' + inputObjectCount +\n\t\t\t'\\n\\tObject name: ' + this.rawMesh.objectName +\n\t\t\t'\\n\\tGroup name: ' + this.rawMesh.groupName +\n\t\t\t'\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\n\t\t\t'\\n\\tVertex count: ' + this.vertices.length / 3 +\n\t\t\t'\\n\\tNormal count: ' + this.normals.length / 3 +\n\t\t\t'\\n\\tUV count: ' + this.uvs.length / 2 +\n\t\t\t'\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\n\t\t\t'\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\n\t\t\t'\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\n\t},\n\n\t/**\n\t * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n\t */\n\t_finalizeRawMesh: function () {\n\n\t\tconst meshOutputGroupTemp = [];\n\t\tlet meshOutputGroup;\n\t\tlet absoluteVertexCount = 0;\n\t\tlet absoluteIndexMappingsCount = 0;\n\t\tlet absoluteIndexCount = 0;\n\t\tlet absoluteColorCount = 0;\n\t\tlet absoluteNormalCount = 0;\n\t\tlet absoluteUvCount = 0;\n\t\tlet indices;\n\t\tfor ( const name in this.rawMesh.subGroups ) {\n\n\t\t\tmeshOutputGroup = this.rawMesh.subGroups[ name ];\n\t\t\tif ( meshOutputGroup.vertices.length > 0 ) {\n\n\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\tif ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = indices[ i ] + absoluteIndexMappingsCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmeshOutputGroupTemp.push( meshOutputGroup );\n\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do not continue if no result\n\t\tlet result = null;\n\t\tif ( meshOutputGroupTemp.length > 0 ) {\n\n\t\t\tresult = {\n\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t_processCompletedMesh: function () {\n\n\t\tconst result = this._finalizeRawMesh();\n\t\tconst haveMesh = result !== null;\n\t\tif ( haveMesh ) {\n\n\t\t\tif ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\n\n\t\t\t\tthis.callbacks.onError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) console.debug( this._createRawMeshReport( this.inputObjectCount ) );\n\t\t\tthis.inputObjectCount ++;\n\n\t\t\tthis._buildMesh( result );\n\t\t\tconst progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\tthis._onProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' +\n\t\t\t\t'] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%' );\n\t\t\tthis._resetRawMesh();\n\n\t\t}\n\n\t\treturn haveMesh;\n\n\t},\n\n\t/**\n\t * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n\t * It is ensured that SubGroups only contain objects with vertices (no need to check).\n\t *\n\t * @param result\n\t */\n\t_buildMesh: function ( result ) {\n\n\t\tconst meshOutputGroups = result.subGroups;\n\n\t\tconst vertexFA = new Float32Array( result.absoluteVertexCount );\n\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\tthis.globalCounts.faces += result.faceCount;\n\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\tconst indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\n\t\tconst colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\n\t\tconst normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\n\t\tconst uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\n\t\tconst haveVertexColors = colorFA !== null;\n\n\t\tlet meshOutputGroup;\n\t\tconst materialNames = [];\n\n\t\tconst createMultiMaterial = ( meshOutputGroups.length > 1 );\n\t\tlet materialIndex = 0;\n\t\tconst materialIndexMapping = [];\n\t\tlet selectedMaterialIndex;\n\t\tlet materialGroup;\n\t\tconst materialGroups = [];\n\n\t\tlet vertexFAOffset = 0;\n\t\tlet indexUAOffset = 0;\n\t\tlet colorFAOffset = 0;\n\t\tlet normalFAOffset = 0;\n\t\tlet uvFAOffset = 0;\n\t\tlet materialGroupOffset = 0;\n\t\tlet materialGroupLength = 0;\n\n\t\tlet materialOrg, material, materialName, materialNameOrg;\n\t\t// only one specific face type\n\t\tfor ( const oodIndex in meshOutputGroups ) {\n\n\t\t\tif ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) continue;\n\t\t\tmeshOutputGroup = meshOutputGroups[ oodIndex ];\n\n\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\tif ( this.rawMesh.faceType < 4 ) {\n\n\t\t\t\tmaterialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\n\n\n\t\t\t} else {\n\n\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\n\t\t\t}\n\n\t\t\tmaterialOrg = this.materials[ materialNameOrg ];\n\t\t\tmaterial = this.materials[ materialName ];\n\n\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\tif ( ( materialOrg === undefined || materialOrg === null ) && ( material === undefined || material === null ) ) {\n\n\t\t\t\tmaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\tmaterial = this.materials[ materialName ];\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'object_group \"' + meshOutputGroup.objectName + '_' +\n\t\t\t\t\t\tmeshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\n\t\t\t\t\t\tmaterialNameOrg + '\"! Assigning \"' + materialName + '\".' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material === undefined || material === null ) {\n\n\t\t\t\tconst materialCloneInstructions = {\n\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst payload = {\n\t\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tmaterials: {\n\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.callbacks.onAssetAvailable( payload );\n\n\t\t\t\t// only set materials if they don't exist, yet\n\t\t\t\tconst matCheck = this.materials[ materialName ];\n\t\t\t\tif ( matCheck === undefined || matCheck === null ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = materialCloneInstructions;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( createMultiMaterial ) {\n\n\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\tselectedMaterialIndex = materialIndexMapping[ materialName ];\n\t\t\t\tif ( ! selectedMaterialIndex ) {\n\n\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\tmaterialIndexMapping[ materialName ] = materialIndex;\n\t\t\t\t\tmaterialNames.push( materialName );\n\t\t\t\t\tmaterialIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\tmaterialGroup = {\n\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t};\n\t\t\t\tmaterialGroups.push( materialGroup );\n\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialNames.push( materialName );\n\n\t\t\t}\n\n\t\t\tvertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\n\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\tif ( indexUA ) {\n\n\t\t\t\tindexUA.set( meshOutputGroup.indices, indexUAOffset );\n\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\n\t\t\t}\n\n\t\t\tif ( colorFA ) {\n\n\t\t\t\tcolorFA.set( meshOutputGroup.colors, colorFAOffset );\n\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\n\t\t\t}\n\n\t\t\tif ( normalFA ) {\n\n\t\t\t\tnormalFA.set( meshOutputGroup.normals, normalFAOffset );\n\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t\tif ( uvFA ) {\n\n\t\t\t\tuvFA.set( meshOutputGroup.uvs, uvFAOffset );\n\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\tlet materialIndexLine = '';\n\t\t\t\tif ( selectedMaterialIndex ) {\n\n\t\t\t\t\tmaterialIndexLine = '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n\n\t\t\t\t}\n\n\t\t\t\tconst createdReport = '\\tOutput Object no.: ' + this.outputObjectCount +\n\t\t\t\t\t'\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\n\t\t\t\t\t'\\n\\t\\tIndex: ' + meshOutputGroup.index +\n\t\t\t\t\t'\\n\\t\\tfaceType: ' + this.rawMesh.faceType +\n\t\t\t\t\t'\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\n\t\t\t\t\t'\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\n\t\t\t\t\tmaterialIndexLine +\n\t\t\t\t\t'\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\n\t\t\t\t\t'\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\n\t\t\t\t\t'\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\n\t\t\t\t\t'\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\tconsole.debug( createdReport );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.outputObjectCount ++;\n\t\tthis.callbacks.onAssetAvailable(\n\t\t\t{\n\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\ttype: 'mesh',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\n\t\t\t},\n\t\t\t[ vertexFA.buffer ],\n\t\t\tindexUA !== null ? [ indexUA.buffer ] : null,\n\t\t\tcolorFA !== null ? [ colorFA.buffer ] : null,\n\t\t\tnormalFA !== null ? [ normalFA.buffer ] : null,\n\t\t\tuvFA !== null ? [ uvFA.buffer ] : null\n\t\t);\n\n\t},\n\n\t_finalizeParsing: function () {\n\n\t\tif ( this.logging.enabled ) console.info( 'Global output object count: ' + this.outputObjectCount );\n\t\tif ( this._processCompletedMesh() && this.logging.enabled ) {\n\n\t\t\tconst parserFinalReport = 'Overall counts: ' +\n\t\t\t\t'\\n\\tVertices: ' + this.globalCounts.vertices +\n\t\t\t\t'\\n\\tFaces: ' + this.globalCounts.faces +\n\t\t\t\t'\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\tconsole.info( parserFinalReport );\n\n\t\t}\n\n\t}\n};\n\nexport { OBJLoader2Parser };\n","import {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Points} from 'three/src/objects/Points';\n/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n\n\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\nconst MeshReceiver = function ( materialHandler ) {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonProgress: null,\n\t\tonMeshAlter: null\n\t};\n\tthis.materialHandler = materialHandler;\n\n};\n\nMeshReceiver.prototype = {\n\n\tconstructor: MeshReceiver,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t/**\n\t *\n\t * @param {Function} onProgress\n\t * @param {Function} onMeshAlter\n\t * @private\n\t */\n\t_setCallbacks: function ( onProgress, onMeshAlter ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\tif ( onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function ) {\n\n\t\t\tthis.callbacks.onMeshAlter = onMeshAlter;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n\t *\n\t * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n\t * @returns {Mesh[]} mesh Array of {@link Mesh}\n\t */\n\tbuildMeshes: function ( meshPayload ) {\n\n\t\tconst meshName = meshPayload.params.meshName;\n\t\tconst buffers = meshPayload.buffers;\n\n\t\tconst bufferGeometry = new BufferGeometry();\n\t\tif ( buffers.vertices !== undefined && buffers.vertices !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( buffers.vertices ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.indices !== undefined && buffers.indices !== null ) {\n\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( buffers.indices ), 1 ) );\n\n\t\t}\n\n\t\tif ( buffers.colors !== undefined && buffers.colors !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'color', new BufferAttribute( new Float32Array( buffers.colors ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.normals !== undefined && buffers.normals !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( buffers.normals ), 3 ) );\n\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\n\t\t}\n\n\t\tif ( buffers.uvs !== undefined && buffers.uvs !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( buffers.uvs ), 2 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinIndex !== undefined && buffers.skinIndex !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinIndex', new BufferAttribute( new Uint16Array( buffers.skinIndex ), 4 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinWeight !== undefined && buffers.skinWeight !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinWeight', new BufferAttribute( new Float32Array( buffers.skinWeight ), 4 ) );\n\n\t\t}\n\n\t\tlet material, materialName, key;\n\t\tconst materialNames = meshPayload.materials.materialNames;\n\t\tconst createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tconst multiMaterials = [];\n\n\t\tfor ( key in materialNames ) {\n\n\t\t\tmaterialName = materialNames[ key ];\n\t\t\tmaterial = this.materialHandler.getMaterial( materialName );\n\t\t\tif ( createMultiMaterial ) multiMaterials.push( material );\n\n\t\t}\n\n\t\tif ( createMultiMaterial ) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tconst materialGroups = meshPayload.materials.materialGroups;\n\t\t\tlet materialGroup;\n\t\t\tfor ( key in materialGroups ) {\n\n\t\t\t\tmaterialGroup = materialGroups[ key ];\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst meshes = [];\n\t\tlet mesh;\n\t\tlet callbackOnMeshAlterResult;\n\t\tlet useOrgMesh = true;\n\t\tconst geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n\t\tif ( this.callbacks.onMeshAlter ) {\n\n\t\t\tcallbackOnMeshAlterResult = this.callbacks.onMeshAlter(\n\t\t\t\t{\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t// here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\t\tif ( callbackOnMeshAlterResult ) {\n\n\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n\t\t\t\tfor ( const i in callbackOnMeshAlterResult.meshes ) {\n\n\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( useOrgMesh ) {\n\n\t\t\tif ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n\t\t\tif ( geometryType === 0 ) {\n\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\n\n\t\t\t} else if ( geometryType === 1 ) {\n\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = new Points( bufferGeometry, material );\n\n\t\t\t}\n\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push( mesh );\n\n\t\t}\n\n\t\tlet progressMessage = meshPayload.params.meshName;\n\t\tif ( meshes.length > 0 ) {\n\n\t\t\tconst meshNames = [];\n\t\t\tfor ( const i in meshes ) {\n\n\t\t\t\tmesh = meshes[ i ];\n\t\t\t\tmeshNames[ i ] = mesh.name;\n\n\t\t\t}\n\n\t\t\tprogressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t} else {\n\n\t\t\tprogressMessage += ': Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t}\n\n\t\tif ( this.callbacks.onProgress ) {\n\n\t\t\tthis.callbacks.onProgress( 'progress', progressMessage, meshPayload.progress.numericalValue );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n};\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nconst LoadedMeshUserOverride = function ( disregardMesh, alteredMesh ) {\n\n\tthis.disregardMesh = disregardMesh === true;\n\tthis.alteredMesh = alteredMesh === true;\n\tthis.meshes = [];\n\n};\n\n\nLoadedMeshUserOverride.prototype = {\n\n\tconstructor: LoadedMeshUserOverride,\n\n\t/**\n\t * Add a mesh created within callback.\n\t *\n\t * @param {Mesh} mesh\n\t */\n\taddMesh: function ( mesh ) {\n\n\t\tthis.meshes.push( mesh );\n\t\tthis.alteredMesh = true;\n\n\t},\n\n\t/**\n\t * Answers if mesh shall be disregarded completely.\n\t *\n\t * @returns {boolean}\n\t */\n\tisDisregardMesh: function () {\n\n\t\treturn this.disregardMesh;\n\n\t},\n\n\t/**\n\t * Answers if new mesh(es) were created.\n\t *\n\t * @returns {boolean}\n\t */\n\tprovidesAlteredMeshes: function () {\n\n\t\treturn this.alteredMesh;\n\n\t}\n};\n\nexport {\n\tMeshReceiver,\n\tLoadedMeshUserOverride\n};\n","import {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\nimport {MaterialLoader} from 'three/src/loaders/MaterialLoader';\nimport {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\nimport {PointsMaterial} from 'three/src/materials/PointsMaterial';\n/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n\n\nconst MaterialHandler = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonLoadMaterials: null\n\t};\n\tthis.materials = {};\n\n};\n\nMaterialHandler.prototype = {\n\n\tconstructor: MaterialHandler,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t_setCallbacks: function ( onLoadMaterials ) {\n\n\t\tif ( onLoadMaterials !== undefined && onLoadMaterials !== null && onLoadMaterials instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoadMaterials = onLoadMaterials;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Creates default materials and adds them to the materials object.\n\t *\n\t * @param overrideExisting boolean Override existing material\n\t */\n\tcreateDefaultMaterials: function ( overrideExisting ) {\n\n\t\tconst defaultMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\n\t\tdefaultMaterial.name = 'defaultMaterial';\n\n\t\tconst defaultVertexColorMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n\t\tdefaultVertexColorMaterial.vertexColors = true;\n\n\t\tconst defaultLineMaterial = new LineBasicMaterial();\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\n\n\t\tconst defaultPointMaterial = new PointsMaterial( { size: 0.1 } );\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\n\n\t\tconst runtimeMaterials = {};\n\t\truntimeMaterials[ defaultMaterial.name ] = defaultMaterial;\n\t\truntimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;\n\t\truntimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;\n\t\truntimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;\n\n\t\tthis.addMaterials( runtimeMaterials, overrideExisting );\n\n\t},\n\n\t/**\n\t * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n\t *\n\t * @param {Object} materialPayload Material update instructions\n\t * @returns {Object} Map of {@link Material}\n\t */\n\taddPayloadMaterials: function ( materialPayload ) {\n\n\t\tlet material, materialName;\n\t\tconst materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n\t\tlet newMaterials = {};\n\n\t\tif ( materialCloneInstructions !== undefined && materialCloneInstructions !== null ) {\n\n\t\t\tlet materialNameOrg = materialCloneInstructions.materialNameOrg;\n\t\t\tmaterialNameOrg = ( materialNameOrg !== undefined && materialNameOrg !== null ) ? materialNameOrg : \"\";\n\t\t\tconst materialOrg = this.materials[ materialNameOrg ];\n\t\t\tif ( materialOrg ) {\n\n\t\t\t\tmaterial = materialOrg.clone();\n\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tObject.assign( material, materialCloneInstructions.materialProperties );\n\n\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'Requested material \"' + materialNameOrg + '\" is not available!' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet materials = materialPayload.materials.serializedMaterials;\n\n\t\tif ( materials !== undefined && materials !== null && Object.keys( materials ).length > 0 ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tlet materialJson;\n\n\t\t\tfor ( materialName in materials ) {\n\n\t\t\t\tmaterialJson = materials[ materialName ];\n\n\t\t\t\tif ( materialJson !== undefined && materialJson !== null ) {\n\n\t\t\t\t\tmaterial = loader.parse( materialJson );\n\n\t\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\t\tconsole.info( 'De-serialized material with name \"' + materialName + '\" will be added.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\n\t\tnewMaterials = this.addMaterials( materials, true, newMaterials );\n\n\t\treturn newMaterials;\n\n\t},\n\n\t/**\n\t * Set materials loaded by any supplier of an Array of {@link Material}.\n\t *\n\t * @param materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @param newMaterials [Object] with named {@link Material}\n\t */\n\taddMaterials: function ( materials, overrideExisting, newMaterials ) {\n\n\t\tif ( newMaterials === undefined || newMaterials === null ) {\n\n\t\t\tnewMaterials = {};\n\n\t\t}\n\n\t\tif ( materials !== undefined && materials !== null && Object.keys( materials ).length > 0 ) {\n\n\t\t\tlet material;\n\t\t\tlet existingMaterial;\n\t\t\tlet add;\n\n\t\t\tfor ( const materialName in materials ) {\n\n\t\t\t\tmaterial = materials[ materialName ];\n\t\t\t\tadd = overrideExisting === true;\n\n\t\t\t\tif ( ! add ) {\n\n\t\t\t\t\texistingMaterial = this.materials[ materialName ];\n\t\t\t\t\tadd = ( existingMaterial === null || existingMaterial === undefined );\n\n\t\t\t\t}\n\n\t\t\t\tif ( add ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = material;\n\t\t\t\t\tnewMaterials[ materialName ] = material;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\t\tconsole.info( 'Material with name \"' + materialName + '\" was added.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.callbacks.onLoadMaterials ) {\n\n\t\t\tthis.callbacks.onLoadMaterials( newMaterials );\n\n\t\t}\n\n\t\treturn newMaterials;\n\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding material.\n\t *\n\t * @returns {Object} Map of {@link Material}\n\t */\n\tgetMaterials: function () {\n\n\t\treturn this.materials;\n\n\t},\n\n\t/**\n\t *\n\t * @param {String} materialName\n\t * @returns {Material}\n\t */\n\tgetMaterial: function ( materialName ) {\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding jsonified material.\n\t *\n\t * @returns {Object} Map of Materials in JSON representation\n\t */\n\tgetMaterialsJSON: function () {\n\n\t\tconst materialsJSON = {};\n\t\tlet material;\n\n\t\tfor ( const materialName in this.materials ) {\n\n\t\t\tmaterial = this.materials[ materialName ];\n\t\t\tmaterialsJSON[ materialName ] = material.toJSON();\n\n\t\t}\n\n\t\treturn materialsJSON;\n\n\t},\n\n\t/**\n\t * Removes all materials\n\t */\n\tclearMaterials: function () {\n\n\t\tthis.materials = {};\n\n\t}\n\n};\n\nexport { MaterialHandler };\n","import {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Object3D} from 'three/src/core/Object3D';\n/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n\nimport { OBJLoader2Parser } from \"./obj2/OBJLoader2Parser.js\";\nimport { MeshReceiver } from \"./obj2/shared/MeshReceiver.js\";\nimport { MaterialHandler } from \"./obj2/shared/MaterialHandler.js\";\n\n/**\n * Creates a new OBJLoader2. Use it to load OBJ data from files or to parse OBJ data from arraybuffer or text.\n *\n * @param {LoadingManager} [manager] The loadingManager for the loader to use. Default is {@link LoadingManager}\n * @constructor\n */\nconst OBJLoader2 = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\tthis.parser = new OBJLoader2Parser();\n\n\tthis.modelName = '';\n\tthis.instanceNo = 0;\n\tthis.baseObject3d = new Object3D();\n\n\tthis.materialHandler = new MaterialHandler();\n\tthis.meshReceiver = new MeshReceiver( this.materialHandler );\n\n\t// as OBJLoader2 is no longer derived from OBJLoader2Parser, we need to override the default onAssetAvailable callback\n\tconst scope = this;\n\tconst defaultOnAssetAvailable = function ( payload ) {\n\n\t\tscope._onAssetAvailable( payload );\n\n\t};\n\n\tthis.parser.setCallbackOnAssetAvailable( defaultOnAssetAvailable );\n\n};\n\nOBJLoader2.OBJLOADER2_VERSION = '3.2.0';\nconsole.info( 'Using OBJLoader2 version: ' + OBJLoader2.OBJLOADER2_VERSION );\n\n\nOBJLoader2.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: OBJLoader2,\n\n\t/**\n\t * See {@link OBJLoader2Parser.setLogging}\n\t * @return {OBJLoader2}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.parser.setLogging( enabled, debug );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setMaterialPerSmoothingGroup}\n\t * @return {OBJLoader2}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.parser.setMaterialPerSmoothingGroup( materialPerSmoothingGroup );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseOAsMesh}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.parser.setUseOAsMesh( useOAsMesh );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseIndices}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.parser.setUseIndices( useIndices );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setDisregardNormals}\n\t * @return {OBJLoader2}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.parser.setDisregardNormals( disregardNormals );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the name of the model.\n\t *\n\t * @param {string} modelName\n\t * @return {OBJLoader2}\n\t */\n\tsetModelName: function ( modelName ) {\n\n\t\tthis.modelName = modelName ? modelName : this.modelName;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the node where the loaded objects will be attached directly.\n\t *\n\t * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to\n\t * @return {OBJLoader2}\n\t */\n\tsetBaseObject3d: function ( baseObject3d ) {\n\n\t\tthis.baseObject3d = ( baseObject3d === undefined || baseObject3d === null ) ? this.baseObject3d : baseObject3d;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Add materials as associated array.\n\t *\n\t * @param {Object} materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @return {OBJLoader2}\n\t */\n\taddMaterials: function ( materials, overrideExisting ) {\n\n\t\tthis.materialHandler.addMaterials( materials, overrideExisting );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnAssetAvailable}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tthis.parser.setCallbackOnAssetAvailable( onAssetAvailable );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnProgress}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tthis.parser.setCallbackOnProgress( onProgress );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnError}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tthis.parser.setCallbackOnError( onError );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnLoad}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tthis.parser.setCallbackOnLoad( onLoad );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once a single mesh is available and it could be altered by the supplied function.\n\t *\n\t * @param {Function} [onMeshAlter]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnMeshAlter: function ( onMeshAlter ) {\n\n\t\tthis.meshReceiver._setCallbacks( this.parser.callbacks.onProgress, onMeshAlter );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once all materials have been loaded and they could be altered by the supplied function.\n\t *\n\t * @param {Function} [onLoadMaterials]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoadMaterials: function ( onLoadMaterials ) {\n\n\t\tthis.materialHandler._setCallbacks( onLoadMaterials );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n\t *\n\t * @param {string}  url A string containing the path/URL of the file to be loaded.\n\t * @param {function} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n\t * @param {function} [onFileLoadProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n\t * @param {function} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n\t * @param {function} [onMeshAlter] Called after every single mesh is made available by the parser\n\t */\n\tload: function ( url, onLoad, onFileLoadProgress, onError, onMeshAlter ) {\n\n\t\tconst scope = this;\n\t\tif ( onLoad === null || onLoad === undefined || ! ( onLoad instanceof Function ) ) {\n\n\t\t\tconst errorMessage = 'onLoad is not a function! Aborting...';\n\t\t\tscope.parser.callbacks.onError( errorMessage );\n\t\t\tthrow errorMessage;\n\n\t\t} else {\n\n\t\t\tthis.parser.setCallbackOnLoad( onLoad );\n\n\t\t}\n\n\t\tif ( onError === null || onError === undefined || ! ( onError instanceof Function ) ) {\n\n\t\t\tonError = function ( event ) {\n\n\t\t\t\tlet errorMessage = event;\n\n\t\t\t\tif ( event.currentTarget && event.currentTarget.statusText !== null ) {\n\n\t\t\t\t\terrorMessage = 'Error occurred while downloading!\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\n\t\t\t\t}\n\n\t\t\t\tscope.parser.callbacks.onError( errorMessage );\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( ! url ) {\n\n\t\t\tonError( 'An invalid url was provided. Unable to continue!' );\n\n\t\t}\n\n\t\tconst urlFull = new URL( url, window.location.href ).href;\n\t\tlet filename = urlFull;\n\t\tconst urlParts = urlFull.split( '/' );\n\t\tif ( urlParts.length > 2 ) {\n\n\t\t\tfilename = urlParts[ urlParts.length - 1 ];\n\t\t\tthis.path = urlParts.slice( 0, urlParts.length - 1 ).join( '/' ) + '/';\n\n\t\t}\n\n\t\tif ( onFileLoadProgress === null || onFileLoadProgress === undefined || ! ( onFileLoadProgress instanceof Function ) ) {\n\n\t\t\tlet numericalValueRef = 0;\n\t\t\tlet numericalValue = 0;\n\t\t\tonFileLoadProgress = function ( event ) {\n\n\t\t\t\tif ( ! event.lengthComputable ) return;\n\n\t\t\t\tnumericalValue = event.loaded / event.total;\n\n\t\t\t\tif ( numericalValue > numericalValueRef ) {\n\n\t\t\t\t\tnumericalValueRef = numericalValue;\n\t\t\t\t\tconst output = 'Download of \"' + url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\n\t\t\t\t\tscope.parser.callbacks.onProgress( 'progressLoad', output, numericalValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tthis.setCallbackOnMeshAlter( onMeshAlter );\n\t\tconst fileLoaderOnLoad = function ( content ) {\n\n\t\t\tscope.parser.callbacks.onLoad( scope.parse( content ), \"OBJLoader2#load: Parsing completed\" );\n\n\t\t};\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path || this.resourcePath );\n\t\tfileLoader.setResponseType( 'arraybuffer' );\n\t\tfileLoader.load( filename, fileLoaderOnLoad, onFileLoadProgress, onError );\n\n\t},\n\n\t/**\n\t * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.\n\t *\n\t * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n\t * @return {Object3D}\n\t */\n\tparse: function ( content ) {\n\n\t\t// fast-fail in case of illegal data\n\t\tif ( content === null || content === undefined ) {\n\n\t\t\tthrow 'Provided content is not a valid ArrayBuffer or String. Unable to continue parsing';\n\n\t\t}\n\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.time( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\n\t\t// Create default materials beforehand, but do not override previously set materials (e.g. during init)\n\t\tthis.materialHandler.createDefaultMaterials( false );\n\n\t\t// code works directly on the material references, parser clear its materials before updating\n\t\tthis.parser.setMaterials( this.materialHandler.getMaterials() );\n\n\t\tif ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing arrayBuffer...' );\n\t\t\tthis.parser.execute( content );\n\n\t\t} else if ( typeof ( content ) === 'string' || content instanceof String ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing text...' );\n\t\t\tthis.parser.executeLegacy( content );\n\n\t\t} else {\n\n\t\t\tthis.parser.callbacks.onError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );\n\n\t\t}\n\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.timeEnd( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\n\t\treturn this.baseObject3d;\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tif ( payload.cmd !== 'assetAvailable' ) return;\n\n\t\tif ( payload.type === 'mesh' ) {\n\n\t\t\tconst meshes = this.meshReceiver.buildMeshes( payload );\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\tthis.baseObject3d.add( mesh );\n\n\t\t\t}\n\n\t\t} else if ( payload.type === 'material' ) {\n\n\t\t\tthis.materialHandler.addPayloadMaterials( payload );\n\n\t\t}\n\n\t}\n\n} );\n\nexport { OBJLoader2 };\n"],"sourceRoot":""}